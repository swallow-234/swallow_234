<!DOCTYPE html>
<html>
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>《程式語言》</title>
  <link href="A0001.css" rel="stylesheet" />        
    </head>
    <body>
        <!--標題-->
        <h1 style="text-align: center;">《程式語言-Python-圖片篩選器》</h1>
<!--內文-->
<div class="column ZZZ" style="color:#B7B7B7">
    <p><h3>Python</h3></p><hr>
<pre><code>
#請在你的終端機或命令提示字元中執行以下指令來安裝：
#pip install opencv-contrib-python scikit-image Pillow send2trash imagehash --user
import os
import cv2
import tkinter as tk
from tkinter import filedialog, ttk
from PIL import Image, ImageTk
from skimage.metrics import structural_similarity as ssim
import numpy as np
from datetime import datetime
import shutil
import random
import re
import imagehash

class Sorting:
    def __init__(self, folder_path, image_paths):
        self.folder_path = folder_path
        self.image_paths = image_paths

    def sort_by_size(self):
        self.image_paths.sort(key=lambda path: os.path.getsize(path), reverse=True)

    def sort_by_mod_date(self):
        self.image_paths.sort(key=lambda path: os.path.getmtime(path), reverse=True)

    def sort_by_creation_date(self):
        self.image_paths.sort(key=lambda path: os.path.getctime(path), reverse=True)
    
    def sort_by_access_date(self):
        self.image_paths.sort(key=lambda path: os.path.getatime(path), reverse=True)

    def sort_by_filename(self):
        self.image_paths.sort(key=lambda path: os.path.basename(path))

    def sort_by_random(self):
        random.shuffle(self.image_paths)

    def sort_by_pixel(self):
        def get_pixel_count(path):
            try:
                with Image.open(path) as img:
                    return img.width * img.height
            except Exception:
                return 0
        self.image_paths.sort(key=get_pixel_count, reverse=True)

    def sort_by_hue(self):
        def get_average_hue(path):
            try:
                img = cv2.imread(path)
                if img is None:
                    return -1
                hsv_img = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)
                h, s, v = cv2.split(hsv_img)
                return np.mean(h)
            except Exception as e:
                print(f"無法取得圖片 {path} 的色相: {e}")
                return -1
        self.image_paths.sort(key=get_average_hue)

class SimilarImageApp:
    def __init__(self, root):
        self.root = root
        self.root.title("相似圖片比較工具")
        
        self.similar_pairs = []
        self.current_pair_index = 0
        
        self.all_image_paths = []
        self.current_batch_index = 0
        self.batch_size = 100
        
        self.images = {}
        self.full_images = {}
        self.current_files = []
        
        self.deleted_folder_path = ""
        self.deleted_records_file = ""
        self.similar_pairs_cache_file = ""
        self.all_image_paths_file = ""
        self.marked_for_deletion = set()
        self.last_marked_file = None 

        self.create_widgets()
        self.load_deleted_records()
        
    def load_deleted_records(self):
        """載入已標記為刪除的檔案名稱列表並設定快取檔案路徑"""
        folder_path = self.folder_path_entry.get()
        
        if not folder_path:
            folder_path = os.getcwd()

        self.deleted_folder_path = os.path.join(folder_path, "_deleted_")
        self.deleted_records_file = os.path.join(self.deleted_folder_path, "deleted_records.txt")
        self.similar_pairs_cache_file = os.path.join(folder_path, "similar_pairs_cache.txt")
        self.all_image_paths_file = os.path.join(folder_path, "all_image_paths.txt")
            
        if not os.path.exists(self.deleted_folder_path):
            os.makedirs(self.deleted_folder_path)
            
        self.marked_for_deletion = set()
        if os.path.exists(self.deleted_records_file):
            with open(self.deleted_records_file, 'r', encoding='utf-8') as f:
                for line in f:
                    self.marked_for_deletion.add(line.strip())

    def save_deleted_records(self):
        """儲存目前已標記為刪除的檔案名稱列表"""
        if self.folder_path_entry.get():
            with open(self.deleted_records_file, 'w', encoding='utf-8') as f:
                for filename in sorted(list(self.marked_for_deletion)):
                    f.write(f"{filename}\n")
    
    def append_similar_pairs_cache(self, pairs):
        """將新找到的相似圖片對附加到快取檔案"""
        if self.folder_path_entry.get():
            with open(self.similar_pairs_cache_file, 'a', encoding='utf-8') as f:
                for (file1, file2), similarity in pairs:
                    f.write(f"{file1},{file2},{similarity}\n")
    
    def load_similar_pairs_cache(self):
        """從文字檔載入相似圖片對並檢查有效性"""
        self.similar_pairs = []
        if os.path.exists(self.similar_pairs_cache_file):
            self.progress_label['text'] = "偵測到快取，載入中..."
            self.root.update_idletasks()
            with open(self.similar_pairs_cache_file, 'r', encoding='utf-8') as f:
                lines = f.readlines()
                self.progressbar['mode'] = 'determinate'
                for i, line in enumerate(lines):
                    try:
                        parts = line.strip().split(',')
                        if len(parts) == 3:
                            file1_name, file2_name, similarity = parts
                            similarity = float(similarity)
                            
                            folder_path = self.folder_path_entry.get()
                            file1_path = os.path.join(folder_path, file1_name)
                            file2_path = os.path.join(folder_path, file2_name)
                            
                            # 檢查檔案是否存在且未被標記為刪除
                            if os.path.exists(file1_path) and os.path.exists(file2_path) and \
                               file1_name not in self.marked_for_deletion and file2_name not in self.marked_for_deletion:
                                self.similar_pairs.append(((file1_name, file2_name), similarity))
                            
                    except Exception as e:
                        print(f"快取檔案格式錯誤，跳過該行: {line.strip()}")
            
            if self.similar_pairs:
                self.similar_pairs.sort(key=lambda x: x[1], reverse=True)
                self.progress_label['text'] = f"已載入 {len(self.similar_pairs)} 組相似圖片。"
                return True
        return False
    
    def create_widgets(self):
        # 創建頂部控制區塊
        top_frame = tk.Frame(self.root, padx=10, pady=10)
        top_frame.pack(fill=tk.X, anchor='n')

        tk.Label(top_frame, text="圖片資料夾路徑:").pack(side=tk.LEFT)
        self.folder_path_entry = tk.Entry(top_frame, width=50)
        self.folder_path_entry.pack(side=tk.LEFT, padx=5, expand=True, fill=tk.X)
        tk.Button(top_frame, text="瀏覽...", command=self.browse_folder).pack(side=tk.LEFT)
        
        tk.Label(top_frame, text="排序方式:").pack(side=tk.LEFT, padx=(10, 5))
        self.sort_option = ttk.Combobox(top_frame, values=["感知哈希", "檔案像素", "檔案大小", "修改日期", "建立日期", "讀取日期", "檔案名稱", "色相", "隨機"], width=12)
        self.sort_option.set("修改日期")
        self.sort_option.pack(side=tk.LEFT)
        
        tk.Button(top_frame, text="尋找相似圖片", command=self.find_similar_images).pack(side=tk.LEFT, padx=5)

        # 圖片顯示區塊
        self.image_frame = tk.Frame(self.root, padx=10, pady=10)
        self.image_frame.pack(fill=tk.BOTH, expand=True)

        self.image_label_A = tk.Label(self.image_frame, text="圖片 A", borderwidth=2, relief="groove")
        self.image_label_A.pack(side=tk.LEFT, padx=10, pady=5, fill=tk.BOTH, expand=True)
        
        self.image_label_B = tk.Label(self.image_frame, text="圖片 B", borderwidth=2, relief="groove")
        self.image_label_B.pack(side=tk.LEFT, padx=10, pady=5, fill=tk.BOTH, expand=True)
        
        self.details_frame = tk.Frame(self.root, padx=10, pady=10)
        self.details_frame.pack(fill=tk.X)
        self.create_details_table()
        
        # 進度條區塊
        self.progress_frame = tk.Frame(self.root, padx=10, pady=5)
        self.progress_frame.pack(fill=tk.X)
        self.progress_label = tk.Label(self.progress_frame, text="準備中...")
        self.progress_label.pack(side=tk.LEFT, padx=5)
        self.progressbar = ttk.Progressbar(self.progress_frame, orient="horizontal", length=300, mode="determinate")
        self.progressbar.pack(side=tk.LEFT, padx=5, expand=True, fill=tk.X)
        
        # 功能按鈕區塊 (固定在視窗底部)
        action_frame_row1 = tk.Frame(self.root, padx=10, pady=5)
        action_frame_row1.pack(fill=tk.X, anchor='s')
        
        tk.Button(action_frame_row1, text="標記檔案 A 為刪除", command=lambda: self.mark_for_deletion_and_next(0)).pack(side=tk.LEFT, padx=5, expand=True)
        tk.Button(action_frame_row1, text="取消上一個刪除標記", command=self.unmark_last_deleted).pack(side=tk.LEFT, padx=5, expand=True)
        tk.Button(action_frame_row1, text="標記檔案 B 為刪除", command=lambda: self.mark_for_deletion_and_next(1)).pack(side=tk.LEFT, padx=5, expand=True)
        
        action_frame_row2 = tk.Frame(self.root, padx=10, pady=5)
        action_frame_row2.pack(fill=tk.X, anchor='s')
        tk.Button(action_frame_row2, text="執行刪除並關閉程式", command=self.execute_deletion).pack(side=tk.LEFT, padx=5, expand=True)

    def create_details_table(self):
        columns = ("detail", "image_a", "image_b")
        self.tree = ttk.Treeview(self.details_frame, columns=columns, show="headings")
        self.tree.heading("detail", text="詳細資料")
        self.tree.heading("image_a", text="圖片 A")
        self.tree.heading("image_b", text="圖片 B")
        self.tree.column("detail", width=120)
        self.tree.column("image_a", width=300)
        self.tree.column("image_b", width=300)
        self.tree.pack(fill=tk.BOTH, expand=True)

        self.tree.tag_configure('editable', background='lightyellow')
        
        self.tree.bind('<Double-1>', self.on_double_click)
        
    def browse_folder(self):
        folder_selected = filedialog.askdirectory()
        if folder_selected:
            self.folder_path_entry.delete(0, tk.END)
            self.folder_path_entry.insert(0, folder_selected)
            self.load_deleted_records()
    
    def find_similar_images(self):
        folder_path = self.folder_path_entry.get()
        if not os.path.isdir(folder_path):
            tk.messagebox.showerror("錯誤", "資料夾路徑無效！")
            return
        
        self.clear_display()
        self.current_pair_index = 0
        self.load_deleted_records()
        
        # 刪除舊的快取檔案以強制重新排序和比對
        if os.path.exists(self.similar_pairs_cache_file):
            os.remove(self.similar_pairs_cache_file)
        if os.path.exists(self.all_image_paths_file):
            os.remove(self.all_image_paths_file)

        valid_extensions = ('.png', '.jpg', '.jpeg', '.bmp', '.gif','.webp','.jfif')
        all_files = [os.path.join(folder_path, f) for f in os.listdir(folder_path)]
        
        self.all_image_paths = [f for f in all_files if f.lower().endswith(valid_extensions) and os.path.exists(f)]
        
        # 過濾掉已經被標記為刪除的檔案
        self.all_image_paths = [p for p in self.all_image_paths if os.path.basename(p) not in self.marked_for_deletion]
        
        sort_by = self.sort_option.get()

        # 根據排序方式選擇不同的比對邏輯
        if sort_by == "感知哈希":
            self.find_similar_by_hash()
            return
        
        # 依據使用者選擇的方式進行排序 (非哈希模式)
        sorter = Sorting(folder_path, self.all_image_paths)
        
        if sort_by == "檔案像素":
            sorter.sort_by_pixel()
        elif sort_by == "檔案大小":
            sorter.sort_by_size()
        elif sort_by == "修改日期":
            sorter.sort_by_mod_date()
        elif sort_by == "建立日期":
            sorter.sort_by_creation_date()
        elif sort_by == "讀取日期":
            sorter.sort_by_access_date()
        elif sort_by == "檔案名稱":
            sorter.sort_by_filename()
        elif sort_by == "色相":
            sorter.sort_by_hue()
        elif sort_by == "隨機":
            sorter.sort_by_random()

        # 檢查快取檔案是否存在，如果存在則直接載入
        if self.load_similar_pairs_cache():
            self.show_current_pair()
            return

        # [步驟一] 將排序後的檔案路徑存入文字檔並釋放暫存記憶體
        with open(self.all_image_paths_file, 'w', encoding='utf-8') as f:
            for path in self.all_image_paths:
                f.write(f"{path}\n")
        
        self.all_image_paths = [] # 釋放記憶體
        self.current_batch_index = 0
        
        # [步驟二] 根據文字檔內的總數計算批次
        with open(self.all_image_paths_file, 'r', encoding='utf-8') as f:
            total_files = len(f.readlines())
        
        self.total_batches = (total_files + self.batch_size - 1) // self.batch_size

        self.root.after(100, self.process_next_batch)

    def find_similar_by_hash(self):
        self.progress_label['text'] = "使用感知哈希比對中..."
        self.root.update_idletasks()
        
        hashes = {}
        for i, path in enumerate(self.all_image_paths):
            try:
                img = Image.open(path)
                h = imagehash.phash(img)
                if h not in hashes:
                    hashes[h] = []
                hashes[h].append(os.path.basename(path))
            except Exception as e:
                print(f"無法為圖片 {os.path.basename(path)} 計算哈希值: {e}")
            
            self.progressbar['value'] = (i + 1) / len(self.all_image_paths) * 100
            self.progress_label['text'] = f"比對進度: {i + 1}/{len(self.all_image_paths)}"
            self.root.update_idletasks()

        self.similar_pairs = []
        for h, filenames in hashes.items():
            if len(filenames) > 1:
                # 將找到的重複圖片組成多個圖片對
                for i in range(len(filenames) - 1):
                    for j in range(i + 1, len(filenames)):
                        self.similar_pairs.append(((filenames[i], filenames[j]), 1.0))
        
        self.similar_pairs.sort(key=lambda x: x[0][0])
        
        if self.similar_pairs:
            self.progress_label['text'] = f"找到 {len(self.similar_pairs)} 組相似圖片。"
            self.progressbar['value'] = 100
            self.show_current_pair()
        else:
            self.clear_display()
            self.progress_label['text'] = "沒有找到任何相似圖片。"
            tk.messagebox.showinfo("完成", "沒有找到任何相似圖片。")

    def process_next_batch(self):
        start_index = self.current_batch_index * self.batch_size
        
        if self.current_batch_index >= self.total_batches:
            self.progress_label['text'] = "所有圖片都已處理完畢。"
            tk.messagebox.showinfo("完成", "所有圖片批次都已處理完畢。")
            
            # 處理完所有批次後，從快取載入所有相似對
            self.load_similar_pairs_cache()
            if self.similar_pairs:
                self.show_current_pair()
            else:
                self.clear_display()
                self.progress_label['text'] = "沒有找到任何相似圖片。"
            return

        # 從文字檔讀取批次檔案路徑
        current_batch_paths = []
        with open(self.all_image_paths_file, 'r', encoding='utf-8') as f:
            for i, line in enumerate(f):
                if i >= start_index and len(current_batch_paths) < self.batch_size:
                    current_batch_paths.append(line.strip())
        
        self.progress_label['text'] = f"處理批次 {self.current_batch_index + 1}/{self.total_batches}..."
        self.root.update_idletasks()
        
        self.load_images_for_batch(current_batch_paths)
        if not self.images:
            self.clear_display()
            self.current_batch_index += 1
            self.root.after(100, self.process_next_batch)
            return
            
        similar_pairs_in_batch = self.find_and_group_similar_images()
        self.append_similar_pairs_cache(similar_pairs_in_batch)
        
        # [步驟三] 釋放記憶體
        self.images = {}
        self.full_images = {}
        
        self.current_batch_index += 1
        self.root.after(100, self.process_next_batch)
        
    def load_images_for_batch(self, image_paths):
        self.images = {}
        self.full_images = {}
        thumbnail_size = (32, 32)
        total_images = len(image_paths)
        
        for i, img_path in enumerate(image_paths):
            filename = os.path.basename(img_path)
            try:
                with Image.open(img_path) as pil_img:
                    img_converted = pil_img.convert('RGBA')
                    img_rgb = cv2.cvtColor(np.array(img_converted), cv2.COLOR_RGBA2RGB)
                    img = cv2.cvtColor(img_rgb, cv2.COLOR_RGB2BGR)

                if img is not None:
                    self.full_images[filename] = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
                    thumbnail = cv2.resize(img, thumbnail_size)
                    self.images[filename] = cv2.cvtColor(thumbnail, cv2.COLOR_BGR2GRAY)
            except Exception as e:
                print(f"無法載入圖片 {filename}: {e}")

            self.progressbar['value'] = (i + 1) / total_images * 100
            self.progress_label['text'] = f"載入批次 {self.current_batch_index + 1}: {i + 1}/{total_images}"
            self.root.update_idletasks()
    
    def find_and_group_similar_images(self):
        similar_pairs = []
        image_names = list(self.images.keys())
        
        grouped_by_type = {}
        for name in image_names:
            file_type = os.path.splitext(name)[1].lower()
            if file_type not in grouped_by_type:
                grouped_by_type[file_type] = []
            grouped_by_type[file_type].append(name)
        
        potential_pairs = []
        
        total_comparisons = sum(len(names) * (len(names) - 1) // 2 for names in grouped_by_type.values())
        progress_count = 0
        
        for file_type, names_list in grouped_by_type.items():
            if len(names_list) < 2:
                continue

            names_with_size = [(name, os.path.getsize(os.path.join(self.folder_path_entry.get(), name))) for name in names_list]
            names_with_size.sort(key=lambda x: x[1])

            for i in range(len(names_with_size)):
                for j in range(i + 1, len(names_with_size)):
                    progress_count += 1
                    
                    name1, size1 = names_with_size[i]
                    name2, size2 = names_with_size[j]
                    
                    if abs(size1 - size2) / max(size1, size2) < 0.1:
                        if self.are_filenames_similar(name1, name2):
                            img1_thumbnail = self.images.get(name1)
                            img2_thumbnail = self.images.get(name2)
                            
                            if img1_thumbnail is None or img2_thumbnail is None:
                                continue
                                
                            similarity_index = ssim(img1_thumbnail, img2_thumbnail)
                            
                            if similarity_index > 0.95:
                                potential_pairs.append((name1, name2))

                    self.progressbar['value'] = progress_count / total_comparisons * 100 if total_comparisons > 0 else 100
                    self.progress_label['text'] = f"批次 {self.current_batch_index + 1}: 初步篩選中: {progress_count}/{total_comparisons}"
                    self.root.update_idletasks()

        self.progress_label['text'] = f"批次 {self.current_batch_index + 1}: 精確比對中..."
        self.progressbar['value'] = 0
        self.root.update_idletasks()
        
        for i, (img1_name, img2_name) in enumerate(potential_pairs):
            img1_full = self.full_images.get(img1_name)
            img2_full = self.full_images.get(img2_name)
            
            if img1_full is None or img2_full is None:
                continue
                
            h1, w1 = img1_full.shape
            h2, w2 = img2_full.shape
            
            if h1 != h2 or w1 != w2:
                img2_resized = cv2.resize(img2_full, (w1, h1))
                similarity_index, _ = ssim(img1_full, img2_resized, full=True)
            else:
                similarity_index, _ = ssim(img1_full, img2_full, full=True)
            
            if similarity_index > 0.9:
                similar_pairs.append(((img1_name, img2_name), similarity_index))
            
            self.progressbar['value'] = (i + 1) / len(potential_pairs) * 100 if len(potential_pairs) > 0 else 100
            self.progress_label['text'] = f"批次 {self.current_batch_index + 1}: 精確比對中: {i + 1}/{len(potential_pairs)}"
            self.root.update_idletasks()
            
        return similar_pairs

    def are_filenames_similar(self, name1, name2):
        base_name1 = os.path.splitext(name1)[0]
        base_name2 = os.path.splitext(name2)[0]
        
        base_name1_clean = re.sub(r'\(.*\)|[0-9]', '', base_name1).strip()
        base_name2_clean = re.sub(r'\(.*\)|[0-9]', '', base_name2).strip()
        
        return base_name1_clean == base_name2_clean
    
    def show_current_pair(self):
        if not self.similar_pairs:
            self.clear_display()
            self.progress_label['text'] = "已無更多相似圖片。"
            return

        file1_name, file2_name = self.similar_pairs[self.current_pair_index][0]
        similarity = self.similar_pairs[self.current_pair_index][1]
        
        folder_path = self.folder_path_entry.get()
        file1_path = os.path.join(folder_path, file1_name)
        file2_path = os.path.join(folder_path, file2_name)
        self.current_files = [file1_path, file2_path]

        self.display_image(file1_path, self.image_label_A)
        self.display_image(file2_path, self.image_label_B)
        
        self.update_details_table(file1_path, file2_path, similarity)
        self.update_mark_buttons()
        
        # 更新進度條標籤，顯示當前圖片對編號和總數
        total_pairs = len(self.similar_pairs)
        self.progress_label['text'] = f"相似圖片 {self.current_pair_index + 1}/{total_pairs} (相似度: {similarity:.4f})"


    def update_mark_buttons(self):
        pass

    def show_next_pair(self):
        if not self.similar_pairs:
            return

        self.current_pair_index += 1
        if self.current_pair_index >= len(self.similar_pairs):
            self.clear_display()
            self.progress_label['text'] = "所有相似圖片都已瀏覽完畢。"
            tk.messagebox.showinfo("完成", "所有相似圖片都已瀏覽完畢。")
        else:
            self.show_current_pair()
        
    def show_prev_pair(self):
        if not self.similar_pairs:
            return
        self.current_pair_index = (self.current_pair_index - 1 + len(self.similar_pairs)) % len(self.similar_pairs)
        self.show_current_pair()
    
    def display_image(self, file_path, label):
        if not os.path.exists(file_path):
            label.config(text=f"檔案不存在\n{os.path.basename(file_path)}", image=None)
            label.image = None
            return

        try:
            img = Image.open(file_path)
            max_width = 400
            max_height = 300
            img.thumbnail((max_width, max_height))
            
            photo = ImageTk.PhotoImage(img)
            label.config(image=photo, text="")
            label.image = photo
        except Exception as e:
            label.config(text=f"無法顯示圖片\n{os.path.basename(file_path)}", image=None)
            label.image = None
            print(f"無法顯示圖片 {file_path}: {e}")

    def update_details_table(self, file_a, file_b, similarity):
        details_a = self.get_file_details(file_a)
        details_b = self.get_file_details(file_b)
        
        for item in self.tree.get_children():
            self.tree.delete(item)

        self.tree.insert("", "end", values=("相似度", f"{similarity:.4f}", f"{similarity:.4f}"))
        self.tree.insert("", "end", values=("解析度 (像素)", details_a['resolution'], details_b['resolution']))
        self.tree.insert("", "end", values=("檔案大小", details_a['size'], details_b['size']))
        self.tree.insert("", "end", values=("檔案類型", details_a['type'], details_b['type']))
        self.tree.insert("", "end", values=("修改日期", details_a['mod_date'], details_b['mod_date']))
        self.tree.insert("", "end", values=("建立日期", details_a['creation_date'], details_b['creation_date']))
        
        self.tree.insert("", "end", values=("檔案名稱(重新命名)", os.path.basename(file_a), os.path.basename(file_b)), tags=('editable',))
    
    def get_file_details(self, file_path):
        details = {
            'resolution': 'N/A',
            'size': 'N/A',
            'type': 'N/A',
            'mod_date': 'N/A',
            'creation_date': 'N/A'
        }
        try:
            if not os.path.exists(file_path):
                return details
            file_stats = os.stat(file_path)
            details['size'] = f"{file_stats.st_size / (1024 * 1024):.2f} MB"
            details['mod_date'] = datetime.fromtimestamp(file_stats.st_mtime).strftime('%Y-%m-%d %H:%M')
            details['creation_date'] = datetime.fromtimestamp(file_stats.st_ctime).strftime('%Y-%m-%d %H:%M')

            img = Image.open(file_path)
            details['resolution'] = f"{img.width}x{img.height}"
            details['type'] = img.format
                
        except Exception as e:
            print(f"無法取得檔案詳細資訊 {file_path}: {e}")
        return details

    def on_double_click(self, event):
        item_id = self.tree.identify_row(event.y)
        column_id = self.tree.identify_column(event.x)
        
        if not item_id or column_id not in ('#2', '#3'):
            return

        item_values = self.tree.item(item_id, 'values')
        if item_values and item_values[0] == "檔案名稱(重新命名)":
            col_index = int(column_id[1]) - 1
            old_filename = item_values[col_index]
            
            rename_window = tk.Toplevel(self.root)
            rename_window.title("重新命名")
            tk.Label(rename_window, text="新檔名:").pack(pady=5)
            
            new_filename_entry = tk.Entry(rename_window, width=50)
            new_filename_entry.insert(0, old_filename)
            new_filename_entry.pack(pady=5, padx=10)
            
            def rename():
                new_filename = new_filename_entry.get()
                if new_filename and new_filename != old_filename:
                    old_path = self.current_files[col_index - 1]
                    new_path = os.path.join(os.path.dirname(old_path), new_filename)
                    try:
                        os.rename(old_path, new_path)
                        self.current_files[col_index - 1] = new_path
                        self.show_current_pair()
                    except Exception as e:
                        tk.messagebox.showerror("錯誤", f"重新命名失敗: {e}")
                rename_window.destroy()

            tk.Button(rename_window, text="確認", command=rename).pack(pady=5)
            new_filename_entry.focus_set()

    def mark_for_deletion_and_next(self, index):
        if not self.current_files:
            self.show_next_pair()
            return
            
        file_path = self.current_files[index]
        filename = os.path.basename(file_path)

        if not os.path.exists(file_path):
            self.show_next_pair()
            return
        
        self.marked_for_deletion.add(filename)
        self.last_marked_file = filename
        self.save_deleted_records()
        self.show_next_pair()

    def unmark_last_deleted(self):
        if not self.last_marked_file:
            tk.messagebox.showinfo("提示", "沒有上一個標記的檔案可供取消。")
            return
            
        if self.last_marked_file in self.marked_for_deletion:
            self.marked_for_deletion.remove(self.last_marked_file)
            self.save_deleted_records()
            tk.messagebox.showinfo("完成", f"已成功取消對 '{self.last_marked_file}' 的刪除標記。")
            self.last_marked_file = None
            self.show_current_pair()
        else:
            tk.messagebox.showinfo("提示", "上一個標記的檔案已不在刪除列表中。")
            self.last_marked_file = None
    
    def execute_deletion(self):
        folder_path = self.folder_path_entry.get()
        if not os.path.isdir(folder_path):
            tk.messagebox.showerror("錯誤", "資料夾路徑無效！")
            self.root.destroy()
            return
        
        if not self.marked_for_deletion:
            tk.messagebox.showinfo("完成", "沒有找到任何標記為刪除的檔案，程式將關閉。")
            
            # 關閉程式時刪除快取檔
            if os.path.exists(self.all_image_paths_file):
                os.remove(self.all_image_paths_file)
            if os.path.exists(self.similar_pairs_cache_file):
                os.remove(self.similar_pairs_cache_file)
                
            self.root.destroy()
            return
        
        deleted_count = 0
        for filename in self.marked_for_deletion:
            source_path = os.path.join(folder_path, filename)
            destination_path = os.path.join(self.deleted_folder_path, filename)
            
            if os.path.exists(source_path):
                try:
                    if os.path.exists(destination_path):
                        base, ext = os.path.splitext(filename)
                        timestamp = datetime.now().strftime("%Y%m%d%H%M%S")
                        new_filename = f"{base}_{timestamp}{ext}"
                        destination_path = os.path.join(self.deleted_folder_path, new_filename)
                        
                    shutil.move(source_path, destination_path)
                    deleted_count += 1
                except Exception as e:
                    print(f"無法將檔案 {filename} 移動到 _deleted_ 資料夾: {e}")
        
        tk.messagebox.showinfo("完成", f"已將 {deleted_count} 個標記為刪除的檔案移動到 _deleted_ 資料夾。")
        
        # 關閉程式時刪除快取檔
        if os.path.exists(self.all_image_paths_file):
            os.remove(self.all_image_paths_file)
        if os.path.exists(self.similar_pairs_cache_file):
            os.remove(self.similar_pairs_cache_file)

        self.root.destroy()

    def clear_display(self):
        self.image_label_A.config(image=None, text="圖片 A")
        self.image_label_B.config(image=None, text="圖片 B")
        self.image_label_A.image = None
        self.image_label_B.image = None
        
        for item in self.tree.get_children():
            self.tree.delete(item)

if __name__ == "__main__":
    root = tk.Tk()
    app = SimilarImageApp(root)
    root.mainloop()
</code></pre>    
    </body>
</html>